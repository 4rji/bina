Te explico **cada una**, r√°pido y t√©cnico, para que entiendas exactamente c√≥mo reviven procesos incluso despu√©s de `kill -9`.

---

# ‚úÖ **1) systemd timer que revive la shell (MUY com√∫n en CCDC)**

Un `.timer` ejecuta un `.service` autom√°ticamente cada X minutos.

Ejemplo atacante:

```
/etc/systemd/system/updater.service
/etc/systemd/system/updater.timer
```

**timer:**

```ini
[Timer]
OnUnitActiveSec=1min
```

**service:**

```ini
[Service]
ExecStart=/bin/bash -c 'reverse shell'
```

Si t√∫ matas la reverse shell ‚Üí
el timer la vuelve a lanzar al minuto exacto.

### C√≥mo detectarlo:

```bash
systemctl list-timers --all
```

Te mostrar√°:

```
updater.timer    updater.service    1min left
```

---

# ‚úÖ **2) cron oculto con @reboot o cada X minutos**

Muchos Blue Teams solo ejecutan:

```bash
crontab -l
```

Pero los Red Teamers **NO** ponen persistencia ah√≠ porque es lo primero que limpian.

La persistencia real est√° en:

### `/etc/crontab`

```
*/1 * * * * root /bin/bash /tmp/R
```

### `/etc/cron.d/`

Ejemplo:

```
/etc/cron.d/apache-upd
```

```
*/2 * * * * root /bin/bash /usr/lib/update.sh
```

Si matas la reverse shell ‚Üí
cron vuelve a lanzar el script al minuto siguiente.

### c√≥mo revisar:

```bash
cat /etc/crontab
ls -l /etc/cron.d/
```

Tambi√©n:

```
ls -l /var/spool/cron/
```

---

# ‚úÖ **3) rc.local ejecutando respawn**

A veces ponen:

```
/etc/rc.local
```

Con esto:

```bash
bash -c 'reverse shell &' 
```

Y systemd lo ejecuta cada vez que reinician el sistema.

No revive autom√°ticamente si matas el proceso,
pero vuelve despu√©s de cada reboot.

---

# ‚úÖ **4) init.d con symlink en runlevels**

Este es cl√°sico en CCDC.

Un script en:

```
/etc/init.d/apache-update
```

Y symlinks en:

```
/etc/rc3.d/S99apache-update
/etc/rc5.d/S99apache-update
```

systemd ‚Äúemula‚Äù los runlevels antiguos.
Si el script ten√≠a un **while true**, revive infinito.

---

# ‚úÖ **5) Script con while true (trampa cl√°sica)**

Ejemplo:

```bash
#!/bin/bash
while true
do
    bash -c 'reverse shell'
    sleep 5
done
```

¬øLe haces `kill -9`?
‚Üí Muere el hijo (reverse shell)
‚Üí Pero NO el padre (el script con el while)

El padre vuelve a lanzar el hijo siempre.

### C√≥mo detectarlo:

```bash
ps aux | grep -v systemd | grep bash
```

Si ves algo como:

```
/bin/bash /tmp/.update.sh
```

es eso.

---

# ‚úÖ **6) Proceso hu√©rfano adoptado por systemd**

Esto pasa cuando:

* Un proceso hijo muere
* El padre tambi√©n muere
* systemd adopta el hijo

Si el mecanismo padre era algo como:

* systemd service
* cron cada minuto
* timer cada minuto
* bucle infinito

‚Üí el proceso reaparece aunque lo mates.

### C√≥mo saber si systemd es el padre:

```bash
ps -o ppid= -p PID
```

Si el PPID es **1** (systemd), el proceso est√° adoptado.

---

# üéØ ¬øQu√© de todo esto coincide EXACTO con lo que dijiste?

### ‚úî Lo matabas con kill -9

### ‚úî Volv√≠a despu√©s de unos minutos

### ‚úî No era crontab -l

### ‚úî Ocurre MUCHO en CCDC

### ‚úî No parece rootkit

La respuesta m√°s probable:

# üëâ **systemd timer o cron en /etc/cron.d reiniciando la reverse shell**

---

Si quieres, dime qu√© OS usaban (Debian/Ubuntu/Rocky) y te doy una lista exacta de comandos defensivos **para revisarlo en 30‚Äì40 segundos en competencia**.
