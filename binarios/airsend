#!/usr/bin/env python3
import socket
import threading
import sys
import os
import random
import string
import time

# Default server settings
DEFAULT_SERVER_HOST = "mic2.4rji.com"
DEFAULT_SERVER_PORT = 443
LOG_DIR = "/opt/4rji/airsend_mess.log"  # used only in server mode

# Dictionary for pending connections (key: code, value: tuple (socket, log_filename))
pending = {}
log_lock = threading.Lock()

def generate_code(length=6):
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))

def is_valid_ip(address):
    parts = address.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        try:
            num = int(part)
        except:
            return False
        if num < 0 or num > 255:
            return False
    return True

def log_data(log_filename, direction, data):
    with log_lock:
        with open(log_filename, "ab") as lf:
            header = f"\n[{time.strftime('%Y-%m-%d %H:%M:%S')} {direction}]:\n".encode()
            lf.write(header)
            lf.write(data)

def relay(src, dst, log_filename, direction):
    """Relays data between two sockets and logs all transferred bytes."""
    try:
        while True:
            data = src.recv(4096)
            if not data:
                break
            dst.sendall(data)
            if log_filename:
                log_data(log_filename, direction, data)
    except:
        pass
    finally:
        src.close()
        dst.close()

def handle_client(conn, addr):
    """Handles incoming connections on the server, pairing them using the provided code."""
    try:
        # Read only up to the first newline for the code.
        code_bytes = b""
        while b"\n" not in code_bytes:
            part = conn.recv(1)
            if not part:
                conn.close()
                return
            code_bytes += part
        code = code_bytes.decode().strip()
        if not code:
            conn.close()
            return
        # Check if there's already a pending connection with this code.
        with threading.Lock():
            if code in pending:
                other_conn, log_filename = pending.pop(code)
                # Log session start.
                if log_filename:
                    session_header = f"\n--- Session started for code '{code}' ---\n".encode()
                    with log_lock:
                        with open(log_filename, "ab") as lf:
                            lf.write(session_header)
                # Start relay threads in both directions.
                threading.Thread(
                    target=relay,
                    args=(conn, other_conn, log_filename, "Client2 -> Client1"),
                    daemon=True
                ).start()
                threading.Thread(
                    target=relay,
                    args=(other_conn, conn, log_filename, "Client1 -> Client2"),
                    daemon=True
                ).start()
            else:
                # Create a new log file for this session.
                timestamp = time.strftime("%Y%m%d_%H%M%S")
                log_filename = os.path.join(LOG_DIR, f"session_{code}_{timestamp}.log")
                pending[code] = (conn, log_filename)
    except Exception as e:
        print("Error handling client:", e)
        conn.close()

def run_server(host=DEFAULT_SERVER_HOST, port=DEFAULT_SERVER_PORT):
    """Starts the relay server and logs all relayed data in LOG_DIR."""
    # Create log directory if needed
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((host, port))
    s.listen(5)
    print(f"Server listening on {host}:{port}")
    try:
        while True:
            conn, addr = s.accept()
            threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()
    except KeyboardInterrupt:
        s.close()
        print("\nServer stopped.")

def send_file(file_path, server_host=DEFAULT_SERVER_HOST, server_port=DEFAULT_SERVER_PORT):
    """Client mode: Connects to the server, generates a code, prints it, and sends:
    [code\n][filename\n][filesize\n][binary content]"""
    if not os.path.isfile(file_path):
        print("File not found:", file_path)
        return
    code = generate_code()
    print("Code:", code)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server_host, server_port))
    s.sendall(code.encode() + b"\n")
    filename = os.path.basename(file_path)
    s.sendall(filename.encode() + b"\n")
    filesize = os.path.getsize(file_path)
    s.sendall(str(filesize).encode() + b"\n")
    with open(file_path, "rb") as f:
        while True:
            chunk = f.read(4096)
            if not chunk:
                break
            s.sendall(chunk)
    s.settimeout(10)
    try:
        ack = s.recv(1024)
        if ack.strip() == b"OK":
            print("Transfer complete.")
        else:
            print("No confirmation received from receiver.")
    except socket.timeout:
        print("Timeout waiting for confirmation.")
    finally:
        s.close()

def receive_file(code, server_host=DEFAULT_SERVER_HOST, server_port=DEFAULT_SERVER_PORT):
    """Client mode: Connects to the server, sends the code, receives:
    [filename\n][filesize\n][binary content] and saves the file locally."""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server_host, server_port))
    s.sendall(code.encode() + b"\n")
    # Receive filename
    filename_bytes = b""
    while True:
        chunk = s.recv(1)
        if not chunk or chunk == b"\n":
            break
        filename_bytes += chunk
    filename = filename_bytes.decode()
    if not filename:
        print("Filename not received.")
        s.close()
        return
    # Receive filesize
    size_bytes = b""
    while True:
        chunk = s.recv(1)
        if not chunk or chunk == b"\n":
            break
        size_bytes += chunk
    try:
        filesize = int(size_bytes.decode().strip())
    except Exception as e:
        print("Error reading file size:", e)
        s.close()
        return
    print(f"Receiving file: {filename} ({filesize} bytes)")
    with open(filename, "wb") as f:
        remaining = filesize
        while remaining > 0:
            data = s.recv(min(4096, remaining))
            if not data:
                break
            f.write(data)
            remaining -= len(data)
    s.sendall(b"OK\n")
    s.close()
    print("File saved as:", filename)

def message_chat(code, server_host=DEFAULT_SERVER_HOST, server_port=DEFAULT_SERVER_PORT):
    """Client mode: Connects to the server using the code and starts an interactive chat.
    If no code is provided, a new one is generated (sender mode).
    If a code is provided, join as receiver.
    Type '/exit' to close the chat."""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server_host, server_port))
    s.sendall(code.encode() + b"\n")
    
    def recv_thread():
        while True:
            data = s.recv(4096)
            if not data:
                break
            sys.stdout.write(data.decode())
            sys.stdout.flush()
    threading.Thread(target=recv_thread, daemon=True).start()
    prompt = "\033[93mType your message ('/exit' to quit):\033[0m "
    sys.stdout.write(prompt)
    sys.stdout.flush()
    try:
        while True:
            line = sys.stdin.readline()
            if not line:
                break
            if line.strip() == "/exit":
                break
            s.sendall(line.encode())
    except KeyboardInterrupt:
        pass
    s.close()

def print_usage():
    print("\033[92mUsage:\033[0m")
    print("  \033[94mServer:\033[0m         sudo /opt/4rji/bin/airsend -s [host] [port]")
    print("  \033[94mSend file:\033[0m      airsend -f <file-path> [host] [port]")
    print("  \033[94mReceive file:\033[0m   airsend -r <code> [host] [port]")
    print("  \033[94mMessage (sender):\033[0m  airsend -m [host] [port]")
    print("  \033[94mMessage (receiver):\033[0m airsend -mr <code> [host] [port]")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    mode = sys.argv[1]
    if mode == "-s":
        host = sys.argv[2] if len(sys.argv) >= 3 else DEFAULT_SERVER_HOST
        port = int(sys.argv[3]) if len(sys.argv) >= 4 else DEFAULT_SERVER_PORT
        run_server(host, port)
    elif mode == "-f":
        if len(sys.argv) < 3:
            print("Please specify the file to send.")
            print_usage()
            sys.exit(1)
        file_path = sys.argv[2]
        host = sys.argv[3] if len(sys.argv) >= 4 else DEFAULT_SERVER_HOST
        port = int(sys.argv[4]) if len(sys.argv) >= 5 else DEFAULT_SERVER_PORT
        send_file(file_path, host, port)
    elif mode == "-r":
        if len(sys.argv) < 3:
            print("Please specify the pairing code.")
            print_usage()
            sys.exit(1)
        code = sys.argv[2]
        host = sys.argv[3] if len(sys.argv) >= 4 else DEFAULT_SERVER_HOST
        port = int(sys.argv[4]) if len(sys.argv) >= 5 else DEFAULT_SERVER_PORT
        receive_file(code, host, port)
    elif mode in ("-m", "-mr"):
        if mode == "-mr":
            if len(sys.argv) < 3:
                print("Please specify the pairing code.")
                print_usage()
                sys.exit(1)
            code = sys.argv[2]
            host = sys.argv[3] if len(sys.argv) >= 4 else DEFAULT_SERVER_HOST
            port = int(sys.argv[4]) if len(sys.argv) >= 5 else DEFAULT_SERVER_PORT
        else:  # mode "-m"
            if len(sys.argv) >= 3 and is_valid_ip(sys.argv[2]):
                code = generate_code()
                print("Code:", code)
                host = sys.argv[2]
                port = int(sys.argv[3]) if len(sys.argv) >= 4 else DEFAULT_SERVER_PORT
            elif len(sys.argv) >= 3:
                code = sys.argv[2]
                host = sys.argv[3] if len(sys.argv) >= 4 else DEFAULT_SERVER_HOST
                port = int(sys.argv[4]) if len(sys.argv) >= 5 else DEFAULT_SERVER_PORT
            else:
                code = generate_code()
                print("Code:", code)
                host = DEFAULT_SERVER_HOST
                port = DEFAULT_SERVER_PORT
        message_chat(code, host, port)
    else:
        print("Unknown mode:", mode)
        print_usage()
        sys.exit(1)