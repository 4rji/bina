#!/usr/bin/env node
// grab-audio.js
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import puppeteer from "puppeteer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

if (process.argv.length < 3) {
  console.error("Uso: ./grab-audio.js <URL> [--wait 10000]");
  process.exit(1);
}

const url = process.argv[2];
const waitArg = process.argv.indexOf("--wait");
const extraWait = waitArg > -1 ? parseInt(process.argv[waitArg + 1] || "0", 10) : 0;

const exts = [".mp3", ".wav", ".ogg", ".oga", ".m4a", ".aac", ".flac", ".opus", ".webm"];
const outDir = path.join(__dirname, "downloads");
fs.mkdirSync(outDir, { recursive: true });

const seen = new Set();

const isAudioUrl = (u) => {
  try {
    const p = new URL(u);
    const lower = p.pathname.toLowerCase();
    return exts.some((e) => lower.endsWith(e));
  } catch {
    return false;
  }
};

const sanitize = (s) => s.replace(/[^\w.-]+/g, "_").slice(0, 120);

(async () => {
  const browser = await puppeteer.launch({ headless: "new", args: ["--no-sandbox"] });
  const page = await browser.newPage();

  // Captura por tipo de contenido y también por extensión
  page.on("response", async (resp) => {
    try {
      const req = resp.request();
      const u = req.url();
      if (seen.has(u)) return;

      const ct = resp.headers()["content-type"] || "";
      const looksAudio = ct.startsWith("audio/") || isAudioUrl(u);

      if (looksAudio) {
        seen.add(u);
        const buf = await resp.buffer();
        const urlObj = new URL(u);
        const base = sanitize(path.basename(urlObj.pathname) || "audio");
        const extGuess =
          path.extname(base) ||
          (ct.startsWith("audio/") ? `.${ct.split("/")[1].split(";")[0]}` : ".bin");

        // evita colisiones
        let name = base.endsWith(extGuess) ? base : `${base}${extGuess}`;
        let finalPath = path.join(outDir, name);
        let i = 1;
        while (fs.existsSync(finalPath)) {
          const stem = name.replace(/\.[^.]+$/, "");
          const ext = path.extname(name);
          finalPath = path.join(outDir, `${stem}_${i}${ext}`);
          i++;
        }

        fs.writeFileSync(finalPath, buf);
        console.log(`[OK] ${finalPath}`);
      }
    } catch { /* noop */ }
  });

  await page.setUserAgent(
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123 Safari/537.36"
  );

  await page.goto(url, { waitUntil: "networkidle2", timeout: 60000 });

  // Opcional: parchea play() para forzar cargas disparadas por interacción
  await page.evaluate(() => {
    const origPlay = HTMLMediaElement.prototype.play;
    HTMLMediaElement.prototype.play = function () {
      const p = origPlay.apply(this, arguments);
      return p.catch(() => Promise.resolve()); // evita rechazos por Autoplay
    };
  });

  if (extraWait > 0) await page.waitForTimeout(extraWait);
  await page.waitForTimeout(2000); // pequeño colchón
  await browser.close();

  console.log(`Descargados: ${seen.size} archivo(s) en ${outDir}`);
})().catch((e) => {
  console.error(e);
  process.exit(1);
});
