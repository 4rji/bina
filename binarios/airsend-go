package main

import (
    "bufio"
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "io"
    "net"
    "os"
    "path/filepath"
    "strconv"
    "strings"
    "sync"
    "time"
)

var (
    DEFAULT_SERVER_HOST = "mic2.4rji.com"
    DEFAULT_SERVER_PORT = 443

    // Directorios
    LOG_DIR   = "/opt/4rji/airsend_mess.log" // Para chat/relay y archivos

    // Diccionarios globales
    pending      = make(map[string]pendingEntry)
    pendingFiles = make(map[string]fileInfo)
    pendingLock  sync.Mutex
)

type pendingEntry struct {
    conn      net.Conn
    logFile   *os.File
    logMutex  sync.Mutex
}

type fileInfo struct {
    filename string
    filesize int
    fullPath string
}

// generateCode crea un código aleatorio de 6 caracteres.
func generateCode() string {
    b := make([]byte, 3)
    _, err := rand.Read(b)
    if err != nil {
        return "abcdef"
    }
    return hex.EncodeToString(b)
}

func isValidIP(address string) bool {
    parts := strings.Split(address, ".")
    if len(parts) != 4 {
        return false
    }
    for _, part := range parts {
        num, err := strconv.Atoi(part)
        if err != nil || num < 0 || num > 255 {
            return false
        }
    }
    return true
}

func readLine(conn net.Conn) (string, error) {
    reader := bufio.NewReader(conn)
    line, err := reader.ReadString('\n')
    return strings.TrimSpace(line), err
}

func logData(pe *pendingEntry, direction string, data []byte) {
    now := time.Now().Format("2006-01-02 15:04:05")
    pe.logMutex.Lock()
    defer pe.logMutex.Unlock()
    pe.logFile.Write([]byte(fmt.Sprintf("\n[%s %s]:\n", now, direction)))
    pe.logFile.Write(data)
}

func relay(src, dst net.Conn, pe *pendingEntry, direction string) {
    defer src.Close()
    defer dst.Close()
    buf := make([]byte, 4096)
    for {
        n, err := src.Read(buf)
        if n > 0 {
            dst.Write(buf[:n])
            if pe != nil {
                logData(pe, direction, buf[:n])
            }
        }
        if err != nil {
            break
        }
    }
}

func handleFileSend(conn net.Conn) {
    defer conn.Close()

    code, err := readLine(conn)
    if err != nil || code == "" {
        return
    }
    filename, err := readLine(conn)
    if err != nil || filename == "" {
        return
    }
    sizeStr, err := readLine(conn)
    if err != nil {
        return
    }
    filesize, err := strconv.Atoi(sizeStr)
    if err != nil {
        return
    }

    os.MkdirAll(LOG_DIR, 0755)
    serverFilename := code + "_" + filename
    fullPath := filepath.Join(LOG_DIR, serverFilename)

    f, err := os.Create(fullPath)
    if err != nil {
        return
    }
    defer f.Close()

    remaining := filesize
    buf := make([]byte, 4096)
    for remaining > 0 {
        n, err := conn.Read(buf)
        if n > 0 {
            f.Write(buf[:n])
            remaining -= n
        }
        if err != nil {
            break
        }
    }
    // Almacena la info en pendingFiles
    pendingLock.Lock()
    pendingFiles[code] = fileInfo{
        filename: filename,
        filesize: filesize,
        fullPath: fullPath,
    }
    pendingLock.Unlock()

    conn.Write([]byte("OK\n"))
}

func handleFileRecv(conn net.Conn) {
    defer conn.Close()
    code, err := readLine(conn)
    if err != nil || code == "" {
        return
    }

    pendingLock.Lock()
    fInfo, ok := pendingFiles[code]
    if ok {
        delete(pendingFiles, code)
    }
    pendingLock.Unlock()

    if !ok {
        conn.Write([]byte("ERR\n"))
        return
    }

    conn.Write([]byte(fInfo.filename + "\n"))
    conn.Write([]byte(strconv.Itoa(fInfo.filesize) + "\n"))
    f, err := os.Open(fInfo.fullPath)
    if err != nil {
        return
    }
    defer f.Close()
    io.Copy(conn, f)
}

func handleChatOrRelay(conn net.Conn, code string) {
    pendingLock.Lock()
    entry, exists := pending[code]
    if exists {
        delete(pending, code)
        pendingLock.Unlock()
        // Inicia el relay en ambas direcciones
        go relay(conn, entry.conn, &entry, "Client2 -> Client1")
        go relay(entry.conn, conn, &entry, "Client1 -> Client2")
    } else {
        // Crea un archivo log
        os.MkdirAll(LOG_DIR, 0755)
        timestamp := time.Now().Format("20060102_150405")
        logPath := filepath.Join(LOG_DIR, fmt.Sprintf("session_%s_%s.log", code, timestamp))
        f, err := os.Create(logPath)
        if err != nil {
            pendingLock.Unlock()
            conn.Close()
            return
        }
        pending[code] = pendingEntry{
            conn:    conn,
            logFile: f,
        }
        pendingLock.Unlock()
    }
}

func handleClient(conn net.Conn) {
    defer conn.Close()
    firstLine, err := readLine(conn)
    if err != nil || firstLine == "" {
        return
    }

    if strings.HasPrefix(firstLine, "FILE") {
        parts := strings.Fields(firstLine)
        if len(parts) >= 2 {
            mode := parts[1]
            if mode == "SEND" {
                handleFileSend(conn)
                return
            } else if mode == "RECV" {
                handleFileRecv(conn)
                return
            } else {
                return
            }
        } else {
            return
        }
    } else {
        handleChatOrRelay(conn, firstLine)
    }
}

func runServer(host string, port int) {
    os.MkdirAll(LOG_DIR, 0755)
    addr := fmt.Sprintf("%s:%d", host, port)
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        fmt.Println("Error al iniciar servidor:", err)
        return
    }
    fmt.Printf("Server listening on %s\n", addr)
    for {
        conn, err := ln.Accept()
        if err != nil {
            continue
        }
        go handleClient(conn)
    }
}

// Funciones de cliente

func sendFile(filePath, serverHost string, serverPort int) {
    info, err := os.Stat(filePath)
    if err != nil || info.IsDir() {
        fmt.Println("File not found:", filePath)
        return
    }
    code := generateCode()
    fmt.Println("Code:", code)
    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error conectando al servidor:", err)
        return
    }
    defer conn.Close()

    conn.Write([]byte("FILE SEND\n"))
    conn.Write([]byte(code + "\n"))
    filename := filepath.Base(filePath)
    conn.Write([]byte(filename + "\n"))
    conn.Write([]byte(strconv.Itoa(int(info.Size())) + "\n"))

    f, err := os.Open(filePath)
    if err != nil {
        return
    }
    defer f.Close()
    io.Copy(conn, f)

    // Espera confirmación
    conn.SetReadDeadline(time.Now().Add(10 * time.Second))
    reply, err := bufio.NewReader(conn).ReadString('\n')
    if err != nil {
        fmt.Println("Timeout waiting for confirmation from server.")
        return
    }
    if strings.TrimSpace(reply) == "OK" {
        fmt.Println("Transfer complete.")
    } else {
        fmt.Println("No confirmation received from server.")
    }
}

func receiveFile(code, serverHost string, serverPort int) {
    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()
    conn.Write([]byte("FILE RECV\n"))
    conn.Write([]byte(code + "\n"))

    reader := bufio.NewReader(conn)
    filename, _ := reader.ReadString('\n')
    filename = strings.TrimSpace(filename)
    if filename == "ERR" || filename == "" {
        fmt.Println("File not available on server.")
        return
    }
    sizeStr, _ := reader.ReadString('\n')
    filesize, err := strconv.Atoi(strings.TrimSpace(sizeStr))
    if err != nil {
        fmt.Println("Error reading file size:", err)
        return
    }
    fmt.Printf("Receiving file: %s (%d bytes)\n", filename, filesize)
    f, err := os.Create(filename)
    if err != nil {
        return
    }
    defer f.Close()
    remaining := filesize
    buf := make([]byte, 4096)
    for remaining > 0 {
        n, err := conn.Read(buf)
        if n > 0 {
            f.Write(buf[:n])
            remaining -= n
        }
        if err != nil {
            break
        }
    }
    fmt.Println("File saved as:", filename)
}

func messageChat(code, serverHost string, serverPort int) {
    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()
    conn.Write([]byte(code + "\n"))

    // Lee mensajes en goroutine
    go func() {
        scanner := bufio.NewScanner(conn)
        for scanner.Scan() {
            fmt.Println(scanner.Text())
        }
    }()

    // Lee de stdin
    scanner := bufio.NewScanner(os.Stdin)
    fmt.Print("Type your message ('/exit' to quit): ")
    for scanner.Scan() {
        line := scanner.Text()
        if line == "/exit" {
            break
        }
        conn.Write([]byte(line + "\n"))
        fmt.Print("Type your message ('/exit' to quit): ")
    }
}

func directSend(filePath, targetHost string, targetPort int) {
    info, err := os.Stat(filePath)
    if err != nil || info.IsDir() {
        fmt.Println("File not found:", filePath)
        return
    }
    addr := fmt.Sprintf("%s:%d", targetHost, targetPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()
    filename := filepath.Base(filePath)
    conn.Write([]byte(filename + "\n"))
    conn.Write([]byte(strconv.Itoa(int(info.Size())) + "\n"))
    f, err := os.Open(filePath)
    if err != nil {
        return
    }
    defer f.Close()
    io.Copy(conn, f)
    fmt.Println("File sent successfully.")
}

func directReceive(listenHost string, listenPort int) {
    addr := fmt.Sprintf("%s:%d", listenHost, listenPort)
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        fmt.Println("Error listening:", err)
        return
    }
    fmt.Printf("Listening on %s...\n", addr)
    for {
        conn, err := ln.Accept()
        if err != nil {
            continue
        }
        go func(c net.Conn) {
            defer c.Close()
            filename, err := readLine(c)
            if err != nil || filename == "" {
                fmt.Println("No file specified. Waiting for next connection...")
                return
            }
            sizeStr, _ := readLine(c)
            filesize, _ := strconv.Atoi(sizeStr)
            fmt.Printf("Receiving file: %s (%d bytes)\n", filename, filesize)
            f, err := os.Create(filename)
            if err != nil {
                return
            }
            defer f.Close()
            remaining := filesize
            buf := make([]byte, 4096)
            for remaining > 0 {
                n, err := c.Read(buf)
                if n > 0 {
                    f.Write(buf[:n])
                    remaining -= n
                }
                if err != nil {
                    break
                }
            }
            fmt.Println("File received successfully.")
        }(conn)
    }
}

func printUsage() {
    fmt.Println("\033[92mUsage:\033[0m")
    fmt.Println("  \033[94mServer:\033[0m                sudo airsend -s [host] [port]")
    fmt.Println("  \033[94mSend file:\033[0m             airsend -f <file-path> [host] [port]")
    fmt.Println("  \033[94mReceive file:\033[0m          airsend -r <code> [host] [port]")
    fmt.Println("  \033[94mMessage (sender):\033[0m      airsend -m [host] [port]")
    fmt.Println("  \033[94mMessage (receiver):\033[0m    airsend -mr <code> [host] [port]")
    fmt.Println("  \033[94mDirect send:\033[0m           airsend -d FILE <target-host> [port]")
    fmt.Println("  \033[94mDirect receive:\033[0m        airsend -ds [listen-host] [port]")
}
func main() {
    if len(os.Args) < 2 {
        printUsage()
        os.Exit(1)
    }
    mode := os.Args[1]
    switch mode {
    case "-s":
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 3 {
            host = os.Args[2]
        }
        if len(os.Args) >= 4 {
            if p, err := strconv.Atoi(os.Args[3]); err == nil {
                port = p
            }
        }
        runServer(host, port)
    case "-f":
        if len(os.Args) < 3 {
            fmt.Println("Please specify the file to send.")
            printUsage()
            os.Exit(1)
        }
        filePath := os.Args[2]
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 4 {
            host = os.Args[3]
        }
        if len(os.Args) >= 5 {
            if p, err := strconv.Atoi(os.Args[4]); err == nil {
                port = p
            }
        }
        sendFile(filePath, host, port)
    case "-r":
        if len(os.Args) < 3 {
            fmt.Println("Please specify the pairing code.")
            printUsage()
            os.Exit(1)
        }
        code := os.Args[2]
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 4 {
            host = os.Args[3]
        }
        if len(os.Args) >= 5 {
            if p, err := strconv.Atoi(os.Args[4]); err == nil {
                port = p
            }
        }
        receiveFile(code, host, port)
    case "-d":
        // Si el segundo argumento es "-", se activa message mode
        if os.Args[2] == "-" {
            targetHost := DEFAULT_SERVER_HOST
            targetPort := DEFAULT_SERVER_PORT
            if len(os.Args) >= 4 {
                targetHost = os.Args[3]
            }
            if len(os.Args) >= 5 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    targetPort = p
                }
            }
            fmt.Println("No file specified. Entering message mode.")
            code := generateCode()
            fmt.Println("Code:", code)
            messageChat(code, targetHost, targetPort)
        } else {
            filePath := os.Args[2]
            targetHost := ""
            targetPort := DEFAULT_SERVER_PORT
            if len(os.Args) >= 3 {
                targetHost = os.Args[3]
            }
            if len(os.Args) >= 4 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    targetPort = p
                }
            }
            directSend(filePath, targetHost, targetPort)
        }
    case "-ds":
        listenHost := "0.0.0.0"
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 3 {
            listenHost = os.Args[2]
        }
        if len(os.Args) >= 4 {
            if p, err := strconv.Atoi(os.Args[3]); err == nil {
                port = p
            }
        }
        directReceive(listenHost, port)
    case "-m", "-mr":
        var code, host string
        port := DEFAULT_SERVER_PORT
        if mode == "-mr" {
            if len(os.Args) < 3 {
                fmt.Println("Please specify the pairing code.")
                printUsage()
                os.Exit(1)
            }
            code = os.Args[2]
            host = DEFAULT_SERVER_HOST
            if len(os.Args) >= 4 {
                host = os.Args[3]
            }
            if len(os.Args) >= 5 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    port = p
                }
            }
        } else { // -m
            if len(os.Args) >= 3 && isValidIP(os.Args[2]) {
                code = generateCode()
                fmt.Println("Code:", code)
                host = os.Args[2]
                if len(os.Args) >= 4 {
                    if p, err := strconv.Atoi(os.Args[3]); err == nil {
                        port = p
                    }
                }
            } else if len(os.Args) >= 3 {
                code = os.Args[2]
                host = DEFAULT_SERVER_HOST
                if len(os.Args) >= 4 {
                    host = os.Args[3]
                }
                if len(os.Args) >= 5 {
                    if p, err := strconv.Atoi(os.Args[4]); err == nil {
                        port = p
                    }
                }
            } else {
                code = generateCode()
                fmt.Println("Code:", code)
                host = DEFAULT_SERVER_HOST
            }
        }
        messageChat(code, host, port)
    default:
        fmt.Println("Unknown mode:", mode)
        printUsage()
        os.Exit(1)
    }
}