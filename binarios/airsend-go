package main

import (
    "bufio"
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "io"
    "net"
    "os"
    "path/filepath"
    "strconv"
    "strings"
    "sync"
    "time"
)

var (
    // Host y puerto por defecto
    DEFAULT_SERVER_HOST = "mic2.4rji.com"
    DEFAULT_SERVER_PORT = 443

    // Directorios (en tu caso, ambos apuntan a /opt/4rji/airsend_mess.log, que es un directorio)
    LOG_DIR   = "/opt/4rji/airsend_mess.log"
    FILES_DIR = "/opt/4rji/airsend_mess.log"

    // Diccionarios globales
    pending      = make(map[string]pendingEntry) // Para chat/relay
    pendingFiles = make(map[string]fileInfo)     // Para archivos
    pendingLock  sync.Mutex
)

type pendingEntry struct {
    conn    net.Conn
    logFile *os.File
    logLock sync.Mutex
}

type fileInfo struct {
    filename string
    filesize int
    fullPath string
}

// generateCode crea un código aleatorio de 6 caracteres hex.
func generateCode() string {
    b := make([]byte, 3)
    _, err := rand.Read(b)
    if err != nil {
        return "abcdef"
    }
    return hex.EncodeToString(b)
}

// isValidIP comprueba si es una IPv4 válida.
func isValidIP(address string) bool {
    parts := strings.Split(address, ".")
    if len(parts) != 4 {
        return false
    }
    for _, part := range parts {
        num, err := strconv.Atoi(part)
        if err != nil || num < 0 || num > 255 {
            return false
        }
    }
    return true
}

// readLine lee hasta el salto de línea.
func readLine(conn net.Conn) (string, error) {
    reader := bufio.NewReader(conn)
    line, err := reader.ReadString('\n')
    if err != nil {
        return "", err
    }
    return strings.TrimSpace(line), nil
}

// logData escribe en el archivo de log con etiqueta de tiempo y dirección.
func logData(pe *pendingEntry, direction string, data []byte) {
    now := time.Now().Format("2006-01-02 15:04:05")
    pe.logLock.Lock()
    defer pe.logLock.Unlock()
    pe.logFile.WriteString(fmt.Sprintf("\n[%s %s]:\n", now, direction))
    pe.logFile.Write(data)
}

// relay reenvía datos entre dos conexiones, registrando logs si se proporciona un pendingEntry.
func relay(src, dst net.Conn, pe *pendingEntry, direction string) {
    defer src.Close()
    defer dst.Close()

    buf := make([]byte, 4096)
    for {
        n, err := src.Read(buf)
        if n > 0 {
            _, _ = dst.Write(buf[:n])
            if pe != nil {
                logData(pe, direction, buf[:n])
            }
        }
        if err != nil {
            break
        }
    }
}

func handleFileSend(conn net.Conn) {
    defer conn.Close()

    code, err := readLine(conn)
    if err != nil || code == "" {
        return
    }
    filename, err := readLine(conn)
    if err != nil || filename == "" {
        return
    }
    sizeStr, err := readLine(conn)
    if err != nil {
        return
    }
    filesize, err := strconv.Atoi(sizeStr)
    if err != nil {
        return
    }

    if err := os.MkdirAll(FILES_DIR, 0755); err != nil {
        fmt.Println("Error creando directorio de archivos:", err)
        return
    }

    serverFilename := code + "_" + filename
    fullPath := filepath.Join(FILES_DIR, serverFilename)

    f, err := os.Create(fullPath)
    if err != nil {
        fmt.Println("Error creando archivo:", err)
        return
    }
    defer f.Close()

    remaining := filesize
    buf := make([]byte, 4096)
    for remaining > 0 {
        n, err := conn.Read(buf)
        if n > 0 {
            _, _ = f.Write(buf[:n])
            remaining -= n
        }
        if n == 0 {
            break
        }
        if err != nil {
            break
        }
    }

    pendingLock.Lock()
    pendingFiles[code] = fileInfo{
        filename: filename,
        filesize: filesize,
        fullPath: fullPath,
    }
    pendingLock.Unlock()

    conn.Write([]byte("OK\n"))
}

func handleFileRecv(conn net.Conn) {
    defer conn.Close()

    code, err := readLine(conn)
    if err != nil || code == "" {
        return
    }
    pendingLock.Lock()
    info, ok := pendingFiles[code]
    if ok {
        delete(pendingFiles, code)
    }
    pendingLock.Unlock()

    if !ok {
        conn.Write([]byte("ERR\n"))
        return
    }

    conn.Write([]byte(info.filename + "\n"))
    conn.Write([]byte(strconv.Itoa(info.filesize) + "\n"))

    f, err := os.Open(info.fullPath)
    if err != nil {
        fmt.Println("Error abriendo archivo para enviar:", err)
        return
    }
    defer f.Close()

    io.Copy(conn, f)
}

func handleChatOrRelay(conn net.Conn, code string) {
    pendingLock.Lock()
    entry, exists := pending[code]
    if exists {
        delete(pending, code)
        pendingLock.Unlock()
        go relay(conn, entry.conn, &entry, "Client2 -> Client1")
        go relay(entry.conn, conn, &entry, "Client1 -> Client2")
    } else {
        if err := os.MkdirAll(LOG_DIR, 0755); err != nil {
            fmt.Println("Error creando directorio de logs:", err)
            conn.Close()
            pendingLock.Unlock()
            return
        }
        timestamp := time.Now().Format("20060102_150405")
        logPath := filepath.Join(LOG_DIR, fmt.Sprintf("session_%s_%s.log", code, timestamp))

        logFile, err := os.Create(logPath)
        if err != nil {
            fmt.Println("Error creando archivo de log:", err)
            conn.Close()
            pendingLock.Unlock()
            return
        }

        pending[code] = pendingEntry{
            conn:    conn,
            logFile: logFile,
        }
        pendingLock.Unlock()
    }
}

func handleClient(conn net.Conn) {
    defer conn.Close()

    firstLine, err := readLine(conn)
    if err != nil || firstLine == "" {
        return
    }
    if strings.HasPrefix(firstLine, "FILE") {
        parts := strings.Fields(firstLine)
        if len(parts) < 2 {
            return
        }
        switch parts[1] {
        case "SEND":
            handleFileSend(conn)
        case "RECV":
            handleFileRecv(conn)
        }
    } else {
        handleChatOrRelay(conn, firstLine)
    }
}

func runServer(host string, port int) {
    if err := os.MkdirAll(LOG_DIR, 0755); err != nil {
        fmt.Println("Error creando directorio de logs:", err)
        return
    }
    addr := fmt.Sprintf("%s:%d", host, port)
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        fmt.Println("Error escuchando en", addr, ":", err)
        return
    }
    fmt.Printf("Server listening on %s\n", addr)

    for {
        conn, err := ln.Accept()
        if err != nil {
            continue
        }
        go handleClient(conn)
    }
}

func sendFile(filePath, serverHost string, serverPort int) {
    info, err := os.Stat(filePath)
    if err != nil || info.IsDir() {
        fmt.Println("File not found:", filePath)
        return
    }
    code := generateCode()
    fmt.Println("Code:", code)

    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error conectando al servidor:", err)
        return
    }
    // No se cierra aquí, se cerrará luego de la confirmación
    defer conn.Close()

    fmt.Fprintf(conn, "FILE SEND\n%s\n%s\n%d\n", code, filepath.Base(filePath), info.Size())

    f, err := os.Open(filePath)
    if err != nil {
        fmt.Println("Error abriendo archivo:", err)
        return
    }
    defer f.Close()

    io.Copy(conn, f)
    // Cierra la parte de escritura para señalar EOF y permitir que el servidor termine de leer.
    if tcpConn, ok := conn.(*net.TCPConn); ok {
        tcpConn.CloseWrite()
    }

    // Aumenta el timeout a 60 segundos
    _ = conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    reply, err := bufio.NewReader(conn).ReadString('\n')
    if err != nil {
        fmt.Println("Timeout waiting for confirmation from server.")
        return
    }
    if strings.TrimSpace(reply) == "OK" {
        fmt.Println("Transfer complete.")
    } else {
        fmt.Println("No confirmation received from server.")
    }
}

func receiveFile(code, serverHost string, serverPort int) {
    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()

    fmt.Fprintf(conn, "FILE RECV\n%s\n", code)
    reader := bufio.NewReader(conn)

    filename, err := reader.ReadString('\n')
    if err != nil {
        fmt.Println("File not available on server.")
        return
    }
    filename = strings.TrimSpace(filename)
    if filename == "ERR" || filename == "" {
        fmt.Println("File not available on server.")
        return
    }

    sizeStr, err := reader.ReadString('\n')
    if err != nil {
        fmt.Println("Error reading file size.")
        return
    }
    filesize, err := strconv.Atoi(strings.TrimSpace(sizeStr))
    if err != nil {
        fmt.Println("Error reading file size:", err)
        return
    }

    fmt.Printf("Receiving file: %s (%d bytes)\n", filename, filesize)

    f, err := os.Create(filename)
    if err != nil {
        fmt.Println("Error creando archivo local:", err)
        return
    }
    defer f.Close()

    remaining := filesize
    buf := make([]byte, 4096)
    for remaining > 0 {
        n, err := conn.Read(buf)
        if n > 0 {
            f.Write(buf[:n])
            remaining -= n
        }
        if err != nil {
            break
        }
    }
    fmt.Println("File saved as:", filename)
}

func messageChat(code, serverHost string, serverPort int) {
    addr := fmt.Sprintf("%s:%d", serverHost, serverPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()

    fmt.Fprintln(conn, code)

    // Goroutine para recibir mensajes
    go func() {
        sc := bufio.NewScanner(conn)
        for sc.Scan() {
            fmt.Println(sc.Text())
        }
    }()

    // Leer desde stdin y enviar
    console := bufio.NewScanner(os.Stdin)
    fmt.Print("\033[93mType your message ('/exit' to quit):\033[0m ")
    for console.Scan() {
        line := console.Text()
        if line == "/exit" {
            break
        }
        fmt.Fprintln(conn, line)
        fmt.Print("\033[93mType your message ('/exit' to quit):\033[0m ")
    }
}

func directSend(filePath, targetHost string, targetPort int) {
    info, err := os.Stat(filePath)
    if err != nil || info.IsDir() {
        fmt.Println("File not found:", filePath)
        return
    }
    addr := fmt.Sprintf("%s:%d", targetHost, targetPort)
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }
    defer conn.Close()

    filename := filepath.Base(filePath)
    fmt.Fprintf(conn, "%s\n%d\n", filename, info.Size())

    f, err := os.Open(filePath)
    if err != nil {
        fmt.Println("Error abriendo archivo:", err)
        return
    }
    defer f.Close()

    io.Copy(conn, f)
    fmt.Println("File sent successfully.")
}

func directReceive(listenHost string, listenPort int) {
    addr := fmt.Sprintf("%s:%d", listenHost, listenPort)
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        fmt.Println("Error listening:", err)
        return
    }
    fmt.Printf("Listening on %s...\n", addr)

    for {
        conn, err := ln.Accept()
        if err != nil {
            continue
        }
        go func(c net.Conn) {
            defer c.Close()

            filename, err := readLine(c)
            if err != nil || filename == "" {
                fmt.Println("No file specified. Waiting for the next connection...")
                return
            }
            sizeStr, _ := readLine(c)
            filesize, _ := strconv.Atoi(sizeStr)
            fmt.Printf("Receiving file: %s (%d bytes)\n", filename, filesize)

            f, err := os.Create(filename)
            if err != nil {
                fmt.Println("Error creando archivo local:", err)
                return
            }
            defer f.Close()

            remaining := filesize
            buf := make([]byte, 4096)
            for remaining > 0 {
                n, err := c.Read(buf)
                if n > 0 {
                    f.Write(buf[:n])
                    remaining -= n
                }
                if err != nil {
                    break
                }
            }
            fmt.Println("File received successfully.")
        }(conn)
    }
}

func printUsage() {
    fmt.Println("\033[92mUsage:\033[0m")
    fmt.Println("  \033[94mServer:\033[0m                sudo airsend -s [host] [port]")
    fmt.Println("  \033[94mSend file:\033[0m             airsend -f <file-path> [host] [port]")
    fmt.Println("  \033[94mReceive file:\033[0m          airsend -r <code> [host] [port]")
    fmt.Println("  \033[94mMessage (sender):\033[0m      airsend -m [host] [port]")
    fmt.Println("  \033[94mMessage (receiver):\033[0m    airsend -mr <code> [host] [port]")
    fmt.Println("  \033[94mDirect send:\033[0m           airsend -d FILE <target-host> [port]")
    fmt.Println("  \033[94mDirect receive:\033[0m        airsend -ds [listen-host] [port]")
}

func main() {
    if len(os.Args) < 2 {
        printUsage()
        os.Exit(1)
    }
    mode := os.Args[1]

    switch mode {
    case "-s": // Server
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 3 {
            host = os.Args[2]
        }
        if len(os.Args) >= 4 {
            if p, err := strconv.Atoi(os.Args[3]); err == nil {
                port = p
            }
        }
        runServer(host, port)

    case "-f": // Send file
        if len(os.Args) < 3 {
            fmt.Println("Please specify the file to send.")
            printUsage()
            os.Exit(1)
        }
        filePath := os.Args[2]
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 4 {
            host = os.Args[3]
        }
        if len(os.Args) >= 5 {
            if p, err := strconv.Atoi(os.Args[4]); err == nil {
                port = p
            }
        }
        sendFile(filePath, host, port)

    case "-r": // Receive file
        if len(os.Args) < 3 {
            fmt.Println("Please specify the pairing code.")
            printUsage()
            os.Exit(1)
        }
        code := os.Args[2]
        host := DEFAULT_SERVER_HOST
        port := DEFAULT_SERVER_PORT
        if len(os.Args) >= 4 {
            host = os.Args[3]
        }
        if len(os.Args) >= 5 {
            if p, err := strconv.Atoi(os.Args[4]); err == nil {
                port = p
            }
        }
        receiveFile(code, host, port)

    case "-d": // Direct send / message
        if len(os.Args) < 3 {
            printUsage()
            os.Exit(1)
        }
        if os.Args[2] == "-" {
            targetHost := DEFAULT_SERVER_HOST
            targetPort := DEFAULT_SERVER_PORT
            if len(os.Args) >= 4 {
                targetHost = os.Args[3]
            }
            if len(os.Args) >= 5 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    targetPort = p
                }
            }
            fmt.Println("No file specified. Entering message mode.")
            code := generateCode()
            fmt.Println("Code:", code)
            messageChat(code, targetHost, targetPort)
        } else {
            filePath := os.Args[2]
            if len(os.Args) < 4 {
                printUsage()
                os.Exit(1)
            }
            targetHost := os.Args[3]
            targetPort := DEFAULT_SERVER_PORT
            if len(os.Args) >= 5 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    targetPort = p
                }
            }
            directSend(filePath, targetHost, targetPort)
        }

    case "-ds": // Direct receive
        listenHost := "0.0.0.0"
        listenPort := DEFAULT_SERVER_PORT
        if len(os.Args) >= 3 {
            listenHost = os.Args[2]
        }
        if len(os.Args) >= 4 {
            if p, err := strconv.Atoi(os.Args[3]); err == nil {
                listenPort = p
            }
        }
        directReceive(listenHost, listenPort)

    case "-m", "-mr": // Chat/relay
        var code, host string
        port := DEFAULT_SERVER_PORT
        if mode == "-mr" {
            if len(os.Args) < 3 {
                fmt.Println("Please specify the pairing code.")
                printUsage()
                os.Exit(1)
            }
            code = os.Args[2]
            host = DEFAULT_SERVER_HOST
            if len(os.Args) >= 4 {
                host = os.Args[3]
            }
            if len(os.Args) >= 5 {
                if p, err := strconv.Atoi(os.Args[4]); err == nil {
                    port = p
                }
            }
        } else {
            if len(os.Args) >= 3 && isValidIP(os.Args[2]) {
                code = generateCode()
                fmt.Println("Code:", code)
                host = os.Args[2]
                if len(os.Args) >= 4 {
                    if p, err := strconv.Atoi(os.Args[3]); err == nil {
                        port = p
                    }
                }
            } else if len(os.Args) >= 3 {
                code = os.Args[2]
                host = DEFAULT_SERVER_HOST
                if len(os.Args) >= 4 {
                    host = os.Args[3]
                }
                if len(os.Args) >= 5 {
                    if p, err := strconv.Atoi(os.Args[4]); err == nil {
                        port = p
                    }
                }
            } else {
                code = generateCode()
                fmt.Println("Code:", code)
                host = DEFAULT_SERVER_HOST
            }
        }
        messageChat(code, host, port)

    default:
        fmt.Println("Unknown mode:", mode)
        printUsage()
        os.Exit(1)
    }
}