#!/usr/bin/env bash
set -euo pipefail

# Captura lsof/netstat/nmap, guarda JSON y envía todo a la API de OpenAI para un resumen en inglés.

OUTPUT_JSON="${OUTPUT_JSON:-scan_results.json}"
SUMMARY_OUTPUT="${SUMMARY_OUTPUT:-scan_summary.txt}"
OPENAI_MODEL="${OPENAI_MODEL:-gpt-4o-mini}"
OPENAI_BASE_URL="${OPENAI_BASE_URL:-https://api.openai.com/v1/chat/completions}"
OPENAI_VERBOSE="${OPENAI_VERBOSE:-0}"
OPENAI_SAVE_RESPONSE="${OPENAI_SAVE_RESPONSE:-}"

LSOF_OUTPUT=""
NETSTAT_OUTPUT=""
NMAP_OUTPUT=""

COLOR_RESET="\033[0m"
COLOR_BLUE="\033[34m"
COLOR_CYAN="\033[36m"
COLOR_GREEN="\033[32m"
COLOR_MAGENTA="\033[35m"
COLOR_RED="\033[31m"
COLOR_YELLOW="\033[33m"

mostrar_titulo() {
    printf "\n%b\n\n" "${COLOR_CYAN}_________________________________________________________${COLOR_RESET}"
}

capturar_comando() {
    local var_name="$1"
    local descripcion="$2"
    local command="$3"

    printf '%b%s%b\n' "$COLOR_YELLOW" "$descripcion" "$COLOR_RESET"
    printf '%b$ %s%b\n' "$COLOR_BLUE" "$command" "$COLOR_RESET"

    local tmp
    tmp=$(mktemp)
    if eval "$command" 2>&1 | tee "$tmp"; then
        printf '%b\n' "${COLOR_GREEN}Comando completado.${COLOR_RESET}"
    else
        printf '%b\n' "${COLOR_RED}El comando terminó con error; la salida se registró igualmente.${COLOR_RESET}"
    fi

    local output
    output=$(<"$tmp")
    rm -f "$tmp"
    printf -v "$var_name" '%s' "$output"

    resaltar_salida "$descripcion" "$output"
}

resaltar_salida() {
    local descripcion="$1"
    local contenido="$2"

    if [[ -z "$contenido" || "$contenido" == "Omitido por el usuario" ]]; then
        return
    fi

    printf '%b\nVista coloreada (%s):%b\n' "$COLOR_GREEN" "$descripcion" "$COLOR_RESET"
    printf '%s' "$contenido" | env \
        COLOR_PORT="$COLOR_MAGENTA" \
        COLOR_NAME="$COLOR_CYAN" \
        COLOR_PID="$COLOR_GREEN" \
        COLOR_STATUS="$COLOR_YELLOW" \
        COLOR_RESET="$COLOR_RESET" python3 - <<'PY'
import os
import re
import sys

port_color = os.environ['COLOR_PORT']
name_color = os.environ['COLOR_NAME']
pid_color = os.environ['COLOR_PID']
status_color = os.environ['COLOR_STATUS']
reset = os.environ['COLOR_RESET']

raw = sys.stdin.read()
if not raw.strip():
    sys.exit(0)

lines = raw.splitlines()
port_re = re.compile(r':(\d{1,5})')
pid_prog_re = re.compile(r'(\d+)/(\S+)')
status_re = re.compile(r'\b(LISTEN|ESTABLISHED|CLOSE_WAIT|TIME_WAIT)\b', re.IGNORECASE)

summary = []
seen = set()

def extract_entry(line):
    match = pid_prog_re.search(line)
    port = None
    if match:
        pid, prog = match.groups()
        port_match = port_re.search(line)
        port = port_match.group(1) if port_match else None
        return pid, prog, port
    cols = line.split()
    if len(cols) >= 2:
        prog = cols[0]
        pid_candidate = cols[1]
        if pid_candidate.isdigit():
            port_match = port_re.search(line)
            if port_match:
                return pid_candidate, prog, port_match.group(1)
    return None

for line in lines:
    colored = line
    colored = pid_prog_re.sub(lambda m: f"{pid_color}{m.group(1)}{reset}/{name_color}{m.group(2)}{reset}", colored)
    colored = port_re.sub(lambda m: f":{port_color}{m.group(1)}{reset}", colored)
    colored = status_re.sub(lambda m: f"{status_color}{m.group(0)}{reset}", colored)
    print(colored)

    entry = extract_entry(line)
    if entry:
        pid, prog, port = entry
        key = (pid, prog, port)
        if key not in seen and port:
            seen.add(key)
            summary.append(key)

if summary:
    print("")
    print(f"{status_color}Puertos detectados:{reset}")
    for pid, prog, port in summary:
        print(f"  Puerto {port_color}{port}{reset} -> {name_color}{prog}{reset} (PID {pid_color}{pid}{reset})")
PY
}

preguntar_y_capturar() {
    local var_name="$1"
    local descripcion="$2"
    local command="$3"

    mostrar_titulo
    printf '%b¿%s?%b\n' "$COLOR_YELLOW" "$descripcion" "$COLOR_RESET"
    local prompt
    prompt=$(printf '%b[Enter] ejecutar / [c] cancelar:%b ' "$COLOR_CYAN" "$COLOR_RESET")

    local respuesta=""
    if ! read -r -n1 -p "$prompt" respuesta; then
        respuesta="c"
    fi
    echo ""

    if [[ "$respuesta" == $'\n' ]]; then
        respuesta=""
    fi

    local respuesta_lc="${respuesta,,}"
    if [[ "$respuesta_lc" == "c" ]]; then
        printf '%b\n' "${COLOR_MAGENTA}Omitido por el usuario.${COLOR_RESET}"
        printf -v "$var_name" 'Omitido por el usuario'
        return
    fi

    capturar_comando "$var_name" "$descripcion" "$command"
}

ejecutar_lsof() {
    preguntar_y_capturar LSOF_OUTPUT "Recopilando conexiones abiertas (lsof -i -P -n)." "sudo lsof -i -P -n"
}

ejecutar_netstat() {
    preguntar_y_capturar NETSTAT_OUTPUT "Mostrando sockets en escucha (netstat -tulpn)." "netstat -tulpn"
}

ejecutar_nmap() {
    printf '%b\n' "${COLOR_BLUE}Comando sugerido: sudo nmap -T4 -p- --min-rate 1000 -D RND:20 localhost (-f opcional para evasión).${COLOR_RESET}"
    preguntar_y_capturar NMAP_OUTPUT "Escaneando puertos locales con nmap." "sudo nmap -T4 -p- --min-rate 1000 -D RND:20 localhost"
}

guardar_json() {
    env LSOF_OUTPUT="$LSOF_OUTPUT" NETSTAT_OUTPUT="$NETSTAT_OUTPUT" NMAP_OUTPUT="$NMAP_OUTPUT" OUTPUT_JSON="$OUTPUT_JSON" \
        COLOR_GREEN="$COLOR_GREEN" COLOR_RESET="$COLOR_RESET" python3 - <<'PY'
import datetime
import json
import os
import platform
from pathlib import Path

path = Path(os.environ["OUTPUT_JSON"])
payload = {
    "generated_at_utc": datetime.datetime.now(datetime.timezone.utc).isoformat(),
    "hostname": platform.node(),
    "platform": platform.platform(),
    "commands": {
        "lsof": os.environ.get("LSOF_OUTPUT", ""),
        "netstat": os.environ.get("NETSTAT_OUTPUT", ""),
        "nmap": os.environ.get("NMAP_OUTPUT", ""),
    },
}
path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
green = os.environ.get("COLOR_GREEN", "")
reset = os.environ.get("COLOR_RESET", "")
print(f"{green}JSON guardado en {path}{reset}")
PY
}

enviar_a_openai() {
    if [[ -z "${OPENAI_API_KEY:-}" ]]; then
        printf '%b\n' "${COLOR_RED}Falta OPENAI_API_KEY en el entorno; no se puede enviar el resumen.${COLOR_RESET}"
        exit 1
    fi

    local payload
    payload=$(env OUTPUT_JSON="$OUTPUT_JSON" OPENAI_MODEL="$OPENAI_MODEL" python3 - <<'PY'
import json
import os

path = os.environ["OUTPUT_JSON"]
model = os.environ.get("OPENAI_MODEL", "gpt-4o-mini")
scan = open(path, "r", encoding="utf-8").read()
messages = [
    {
        "role": "system",
        "content": (
            "You summarize local network posture in concise English. "
            "Highlight listening ports/services/process names, note suspicious or unknown ports, "
            "and mention if any data is missing."
        ),
    },
    {
        "role": "user",
        "content": f"Here is JSON with lsof/netstat/nmap outputs:\n```\n{scan}\n```",
    },
]
print(json.dumps({"model": model, "messages": messages, "temperature": 0.2}))
PY
)

    local response
    local tmp_err
    tmp_err=$(mktemp)

    printf '%b\n' "${COLOR_BLUE}Enviando a OpenAI ($OPENAI_BASE_URL) con modelo $OPENAI_MODEL...${COLOR_RESET}"
    if [[ "$OPENAI_VERBOSE" == "1" ]]; then
        local key_prefix="${OPENAI_API_KEY:0:8}"
        printf '%b\n' "${COLOR_MAGENTA}OPENAI_API_KEY prefix: ${key_prefix}...${COLOR_RESET}"
    fi

    if ! response=$(printf '%s' "$payload" | curl -sS ${OPENAI_VERBOSE:+-v} --fail-with-body "$OPENAI_BASE_URL" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        --data-binary @- 2>"$tmp_err"); then
        printf '%b\n' "${COLOR_RED}Falló la llamada a la API de OpenAI. Detalle de error:${COLOR_RESET}"
        cat "$tmp_err"
        if [[ -n "${response:-}" ]]; then
            echo ""
            printf '%b\n' "${COLOR_YELLOW}Respuesta HTTP (si la hubo):${COLOR_RESET}"
            printf '%s\n' "$response"
        fi
        rm -f "$tmp_err"
        exit 1
    fi
    rm -f "$tmp_err"

    if [[ -n "$OPENAI_SAVE_RESPONSE" ]]; then
        printf '%s' "$response" >"$OPENAI_SAVE_RESPONSE"
        printf '%b\n' "${COLOR_GREEN}Respuesta completa guardada en $OPENAI_SAVE_RESPONSE${COLOR_RESET}"
    fi

    local summary
    if ! summary=$(env OPENAI_RESPONSE="$response" COLOR_RED="$COLOR_RED" COLOR_YELLOW="$COLOR_YELLOW" COLOR_RESET="$COLOR_RESET" python3 - <<'PY'
import json
import os
import sys

def from_choices(data):
    choices = data.get("choices")
    if choices:
        message = choices[0].get("message", {})
        content = message.get("content", "")
        if isinstance(content, list):  # responses that already chunk content
            content = "".join(part.get("text", "") for part in content)
        return content.strip()
    return None

def from_responses_api(data):
    output = data.get("output")
    if not output:
        return None
    first = output[0]
    if isinstance(first, dict):
        content = first.get("content") or []
        if isinstance(content, list):
            texts = [chunk.get("text", "") for chunk in content if isinstance(chunk, dict)]
            return "".join(texts).strip()
    return None

raw = os.environ.get("OPENAI_RESPONSE", "")
if not raw:
    print("Respuesta vacía de la API", file=sys.stderr)
    sys.exit(1)

try:
    data = json.loads(raw)
except json.JSONDecodeError:
    print("No fue posible decodificar JSON desde la API", file=sys.stderr)
    sys.exit(1)

text = from_choices(data) or from_responses_api(data) or data.get("text")
if text:
    print(text.strip())
    sys.exit(0)

error = data.get("error")
if error:
    if isinstance(error, dict):
        message = error.get("message") or json.dumps(error)
    else:
        message = str(error)
    red = os.environ.get("COLOR_RED", "")
    reset = os.environ.get("COLOR_RESET", "")
    print(f"{red}OpenAI devolvió un error: {message}{reset}", file=sys.stderr)
else:
    yellow = os.environ.get("COLOR_YELLOW", "")
    reset = os.environ.get("COLOR_RESET", "")
    print(f"{yellow}Respuesta de OpenAI no reconocida: claves={list(data.keys())}{reset}", file=sys.stderr)
sys.exit(1)
PY
    ); then
        printf '%b\n' "${COLOR_RED}No se pudo interpretar la respuesta HTTP completa; se imprime a continuación:${COLOR_RESET}" >&2
        printf '%s\n' "$response" >&2
        exit 1
    fi

    echo ""
    printf '%b\n' "${COLOR_CYAN}Resumen en inglés (basado en la API de OpenAI):${COLOR_RESET}"
    printf '%b\n' "${COLOR_GREEN}$summary${COLOR_RESET}"

    printf '%s\n' "$summary" >"$SUMMARY_OUTPUT"
    printf '%bResumen guardado en %s%b\n' "$COLOR_GREEN" "$SUMMARY_OUTPUT" "$COLOR_RESET"
    rm -f "$OUTPUT_JSON"
}

preguntar_envio() {
    printf '\n%bEnviar resultados a OpenAI?%b\n' "$COLOR_CYAN" "$COLOR_RESET"
    local prompt
    prompt=$(printf '%b[Enter] enviar / [c] cancelar:%b ' "$COLOR_YELLOW" "$COLOR_RESET")

    local respuesta=""
    if ! read -r -n1 -p "$prompt" respuesta; then
        respuesta="c"
    fi
    echo ""

    if [[ "$respuesta" == $'\n' ]]; then
        respuesta=""
    fi

    local respuesta_lc="${respuesta,,}"
    if [[ "$respuesta_lc" == "c" || "$respuesta_lc" == "n" ]]; then
        printf '%b\n' "${COLOR_MAGENTA}Cancelado por el usuario; se elimina ${OUTPUT_JSON}.${COLOR_RESET}"
        rm -f "$OUTPUT_JSON"
        return
    fi

    enviar_a_openai
}

main() {
    printf '%b\n' "${COLOR_CYAN}Recolección local: se mostrará la salida de cada comando y se guardará un JSON.${COLOR_RESET}"
    ejecutar_lsof
    ejecutar_netstat
    ejecutar_nmap
    guardar_json
    preguntar_envio
}

main "$@"
