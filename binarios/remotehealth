#!/usr/bin/env bash
set -euo pipefail

BIN_PATH="/opt/4rji/bin"
BIN_FILE="$BIN_PATH/remotehealth"
SERVICE_FILE="/etc/systemd/system/remotehealth.service"

echo "[*] Creando directorio $BIN_PATH ..."
mkdir -p "$BIN_PATH"

echo "[*] Instalando ejecutable Node en $BIN_FILE ..."
cat > "$BIN_FILE" <<'EOF'
#!/usr/bin/env node
const http = require('http');
const url = require('url');
const { execFile } = require('child_process');

const HOST = process.env.HOST || '0.0.0.0';
const PORT = Number(process.env.PORT || 56743);
const TOKEN = process.env.REMOTEHEALTH_TOKEN || null;
const SERVICES = (process.env.SERVICES || 'zeek,suricata,filebeat,elasticsearch')
  .split(',').map(s => s.trim()).filter(Boolean);

function checkService(name) {
  return new Promise((resolve) => {
    execFile('systemctl', ['is-active', '--quiet', name], (err) => {
      resolve({ name, ok: !err });
    });
  });
}

async function buildStatus() {
  const results = await Promise.all(SERVICES.map(checkService));
  const status = Object.fromEntries(results.map(r => [r.name, r.ok ? 'ok' : 'down']));
  const ok = results.every(r => r.ok);
  return { ok, ...status };
}

function send(res, code, dataObj) {
  const body = JSON.stringify(dataObj);
  res.writeHead(code, {
    'Content-Type': 'application/json',
    'Content-Length': Buffer.byteLength(body),
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Authorization, Content-Type',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
  });
  res.end(body);
}

const server = http.createServer(async (req, res) => {
  if (req.method === 'OPTIONS') {
    res.writeHead(204, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Authorization, Content-Type',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Max-Age': '86400',
    });
    return res.end();
  }

  const { pathname } = url.parse(req.url || '/');
  if (pathname !== '/health') return send(res, 404, { ok: false, error: 'not_found' });

  if (TOKEN) {
    const auth = req.headers['authorization'] || '';
    const m = auth.match(/^Bearer\s+(.+)$/i);
    if (!m || m[1] !== TOKEN) return send(res, 401, { ok: false, error: 'unauthorized' });
  }

  try {
    const payload = await buildStatus();
    return send(res, payload.ok ? 200 : 503, payload);
  } catch (e) {
    return send(res, 500, { ok: false, error: 'internal_error' });
  }
});

server.listen(PORT, HOST, () => {});
process.on('SIGTERM', () => server.close(() => process.exit(0)));
process.on('SIGINT', () => server.close(() => process.exit(0)));
EOF

chmod +x "$BIN_FILE"

echo "[*] Creando servicio systemd en $SERVICE_FILE ..."
cat > "$SERVICE_FILE" <<EOF
[Unit]
Description=Remote Health endpoint (/health)
After=network.target

[Service]
ExecStart=/usr/bin/node $BIN_FILE
Environment=HOST=0.0.0.0
Environment=PORT=56743
# Opcional: token de seguridad
# Environment=REMOTEHEALTH_TOKEN=MI_TOKEN
Restart=always
User=root
WorkingDirectory=$BIN_PATH

[Install]
WantedBy=multi-user.target
EOF

echo "[*] Recargando systemd y habilitando servicio ..."
systemctl daemon-reload
systemctl enable --now remotehealth

echo "[*] Estado del servicio:"
systemctl status remotehealth --no-pager

echo "[*] Logs en vivo:"
journalctl -u remotehealth -f